# Pretty-printers for plain pointers
 
# Copyright (C) 2010 WinGDB.com
 
# Boost Software License - Version 1.0 - August 17th, 2003
 
# Permission is hereby granted, free of charge, to any person or organization
# obtaining a copy of the software and accompanying documentation covered by
# this license (the "Software") to use, reproduce, display, distribute,
# execute, and transmit the Software, and to prepare derivative works of the
# Software, and to permit third-parties to whom the Software is furnished to
# do so, all subject to the following:
 
# The copyright notices in the Software and this entire statement, including
# the above license grant, this restriction and the following disclaimer,
# must be included in all copies of the Software, in whole or in part, and
# all derivative works of the Software, unless such copies or derivative
# works are solely in the form of machine-executable object code generated by
# a source language processor.
 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
# SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
# FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.

# This visualizer is a workaround for a bug in GDB 7.0.
# For pointer values, GDB provides automatic target extraction (the varobj
# returns a child corresponding to the pointer's target). This is good.
# However, pretty printers don't work with that value for unknown reason.
# This workaround overcomes that by pretty-printing the pointer itself
# and effectively emulating the above function. Other pretty printers
# work recursively this time, as expected.

import gdb
import re
 
class PointerPrinter:
    "Pretty Printer for pointers"
 
    def __init__(self, value):
        self.value = value
 
    class _iterator:
        def __init__(self, value, empty):
            self.value = value
            self.done = empty
 
        def __iter__(self):
            return self
 
        def advance(self):
            if(self.done):
                raise StopIteration
            self.done = True
            return ('value', self.value.dereference())
 
        def next(self):
            return self.advance()

        def __next__(self):
            return self.advance()

    def children(self):
        try:
            return self._iterator(self.value, False)
        except:
            return self._iterator('', True)

    def display_hint(self):
        return "#" + self.to_string()
 
    def to_string(self):
        v = int ( self.value )
        return "0x%x" % ( v, )
 
def find_pretty_printer(value):
    "Find a pretty printer suitable for value"
    
    type = value.type.unqualified().strip_typedefs()

    if type.code == gdb.TYPE_CODE_PTR:
       return PointerPrinter ( value )
    else:
       return None

def register_pointer_printers(obj):
    "Register pointer printers."
    if obj == None:
        obj = gdb
    obj.pretty_printers.append(find_pretty_printer)
 